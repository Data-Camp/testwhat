% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/check-fun-op.R
\name{check_fun_op}
\alias{check_fun_op}
\alias{check_function}
\alias{check_operator}
\alias{check_arg}
\alias{check_equal.ArgumentState}
\title{Check whether a student correctly called a function/operator}
\usage{
check_function(state, name, index = 1, not_called_msg = NULL,
  append = TRUE)

check_operator(state, name, index = 1, append = TRUE,
  not_called_msg = NULL)

check_arg(state, arg, arg_not_specified_msg = NULL, append = TRUE)

\method{check_equal}{ArgumentState}(state, incorrect_msg = NULL,
  eval = TRUE, eq_condition = "equivalent", append = TRUE, ...)
}
\arguments{
\item{state}{state to start from (for \code{check_} functions)}

\item{name}{name of the function/operator as a string, e.g. \code{"mean"} or
\code{"+"}}

\item{index}{integer that specifies which call of \code{name} in the
solution code will be checked.}

\item{not_called_msg}{custom feedback message in case the student did not
call the function often enough.}

\item{append}{Whether or not to append the feedback to feedback built in
previous states}

\item{arg}{name of argument to specify (for \code{check_arg})}

\item{arg_not_specified_msg}{custom message in case argument was not
specified (for \code{check_arg})}

\item{incorrect_msg}{custom feedback message in case the student did not call
the function with the same argument values as in the sample solution. You
can specify a vector of arguments with the same length as \code{args}, to
have argument-specific custom feedback.}

\item{eval}{logical vector indicating whether and how to compare arguments.
If \code{eval} is \code{NA}, student and solution argument are not
compared. If \code{eval} is \code{FALSE}, the string versions of the
arguments are compared. If \code{eval} is \code{TRUE}, the argument in the
student code is evaluated in the student environment and the argument in
the solution code is evaluated in the solution environment, and their
results are compared. Setting this to \code{FALSE} can be useful, e.g., to
check whether the student supplied a large predefined object, or when you're
in a sub-SCT where the environments are not unambiguously available.}

\item{eq_condition}{character vector indicating how to perform the
comparison for each argument. See \code{\link{is_equal}}}

\item{...}{S3 stuff}

\item{args}{character vector of argument names that the student should have
supplied in the function calls.}

\item{args_not_specified_msg}{custom feedback message in case the student did
call the function with the argument specified.}
}
\description{
Check whether a student called a function correctly. Note:
\code{test_function} and \code{test_function_v2} are now identical and either
can be used.
}
\examples{
\dontrun{
# Example 1
mean(1:3)

# SCT
ex() \%>\% check_function("mean") \%>\% check_arg("x") \%>\% check_equal()

# Example 2
mean(c(NA, 1, 2), na.rm = TRUE)

# SCT
funstate <- ex() \%>\% check_function("mean")
funstate \%>\% check_arg("x") \%>\% check_equal()
funstate \%>\% check_arg("na.rm") \%>\% check_equal()

# Example 3
5 + 4

# SCT
ex() \%>\% check_operator("+") \%>\% check_result() \%>\% check_equal()
}

}

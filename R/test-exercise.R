#' Run all tests for an exercise
#'
#' Run all tests for an exercise and report the results (including feedback).
#' This function is run by R Backend and should not be used by course creators.
#'
#' @param sct Submission correctness tests as a character string.
#' @param ex_type Type of the exercise
#' @param pec pre-exercise-code
#' @param student_code character string representing the student code
#' @param solution_code character string representing the solution code
#' @param solution_env environment containing the objects defined by solution code
#' @param output_list the output structure that is generated by RBackend
#' @param in_test_mode whether or not the system is in 'content testing mode'. 
#' If this is the case, e.g. \code{\link{test_or}} will behave differently.
#'
#' @return A list with components \code{passed} that indicates whether all
#' tests were sucessful, and \code{feedback} that contains a feedback message.
#'
#' @export
test_exercise <- function(sct, 
                          ex_type, 
                          pec,
                          student_code,
                          solution_code,
                          solution_env,
                          output_list,
                          in_test_mode = FALSE) {
  
  # Store everything that's needed locally (initialize does a full reset)
  tw$initialize(list(pec = pec,
                     student_code = student_code,
                     student_pd = if (ex_type == "MarkdownExercise") NULL else build_pd(student_code),
                     student_env = globalenv(),
                     solution_code = solution_code,
                     solution_pd = if (ex_type == "MarkdownExercise") NULL else build_pd(solution_code),
                     solution_env = solution_env,
                     output_list = output_list,
                     in_test_mode = isTRUE(in_test_mode)))

  # Execute sct with the DataCamp reporter such that it collects test results
  reporter <- DataCampReporter$new()
  old <- set_reporter(reporter)
  on.exit(set_reporter(old))
  run_until_fail(parse(text = sct))

  outcome <- reporter$end_reporter()
  # If markdown exercise, remove line information
  if (ex_type == "MarkdownExercise" && "line_start" %in% names(outcome)) {
    outcome[c("line_start", "column_start", "line_end", "column_end")] <- NULL
  }
  
  return(outcome)
}

run_until_fail <- function(code) {
  eval_fail <- try(eval(code), silent = TRUE)
  if (inherits(eval_fail, "try-error")) {
    cond <- attr(eval_fail, "condition")$message
    if (identical(cond, sct_failed_msg)) {
      # The SCT failed
      return(FALSE)
    } else {
      # Something actually went wrong, not an SCT that failed
      stop(attr(eval_fail, "condition"))
    }
  } else {
    # The SCT passed
    return(TRUE)
  }
}